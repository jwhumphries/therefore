package views

import (
	"strconv"
	"strings"
)

// formatCitationNumber formats a citation number as [1], [2], etc.
func formatCitationNumber(n int) string {
	return "[" + strconv.Itoa(n) + "]"
}

// Figure renders an image with optional caption.
templ Figure(src, caption, alt string) {
	<figure class="my-8" data-component="lightbox">
		<img
			src={ src }
			alt={ alt }
			class="w-full rounded-lg cursor-pointer hover:opacity-90 transition-opacity"
		/>
		if caption != "" {
			<figcaption class="mt-2 text-center text-sm text-default-500 italic">
				{ caption }
			</figcaption>
		}
	</figure>
}

// Quote renders a styled blockquote with attribution.
templ Quote(author, source, content string) {
	<blockquote class="my-8 pl-6 border-l-4 border-primary">
		<p class="text-lg font-serif italic text-default-700">
			@templ.Raw(content)
		</p>
		if author != "" || source != "" {
			<footer class="mt-3 text-default-500">
				<span>â€”</span>
				if author != "" {
					<cite class="font-semibold">{ author }</cite>
				}
				if source != "" {
					<span>, </span>
					<cite class="italic">{ source }</cite>
				}
			</footer>
		}
	</blockquote>
}

// Sidenote renders a margin note as a popover.
templ Sidenote(id, content string) {
	<span class="sidenote-wrapper" data-component="sidenote" data-sidenote-content={ content }>
		<button type="button" class="sidenote-trigger cursor-pointer text-accent font-medium"></button>
	</span>
}

// CitationRef renders an inline citation reference with popover.
// The number is determined by the citation-counter CSS counter.
templ CitationRef(text, url string) {
	<span class="citation-wrapper" data-component="citation" data-citation-text={ text } data-citation-url={ url }>
		<button type="button" class="citation-trigger cursor-pointer"></button>
	</span>
}

// CitationEntry represents a citation for the citations list.
type CitationEntry struct {
	Number int
	Text   string
	URL    string
}

// CitationsAccordion renders the collapsible citations section at the bottom of a post.
templ CitationsAccordion(citations []CitationEntry) {
	if len(citations) > 0 {
		<details class="citations-accordion mt-12 border-t border-border pt-6">
			<summary class="cursor-pointer text-sm font-medium text-muted hover:text-foreground transition-colors list-none flex items-center gap-2">
				<svg class="citations-chevron w-4 h-4 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
				</svg>
				Citations ({ len(citations) })
			</summary>
			<ol class="citations-list mt-4 space-y-2 text-sm">
				for _, c := range citations {
					<li value={ formatCitationNumber(c.Number) } class="flex gap-2">
						<span class="text-muted flex-shrink-0">{ formatCitationNumber(c.Number) }</span>
						<a href={ templ.SafeURL(c.URL) } target="_blank" rel="noopener noreferrer" class="text-accent hover:underline">
							{ c.Text }
							<svg class="inline-block w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
							</svg>
						</a>
					</li>
				}
			</ol>
		</details>
	}
}

// Timeline renders a chronological list of events.
templ Timeline(start, end string, events []TimelineEvent) {
	<ul class="timeline" data-component="timeline" data-start={ start } data-end={ end }>
		for i, event := range events {
			<li>
				if i > 0 {
					<hr class="timeline-hr-start"/>
				} else {
					<hr class="invisible timeline-hr-start"/>
				}
				if i%2 == 0 {
					<div class="timeline-start timeline-date text-center">{ event.Date }</div>
					<div class="timeline-middle">
						<div class="timeline-circle"></div>
					</div>
					<div class="timeline-end timeline-box text-center">
						<h4 class="font-semibold font-display text-center">{ event.Title }</h4>
						if event.Description != "" {
							<p class="text-sm text-default-600 mt-1 text-center">{ event.Description }</p>
						}
					</div>
				} else {
					<div class="timeline-start timeline-box text-center">
						<h4 class="font-semibold font-display text-center">{ event.Title }</h4>
						if event.Description != "" {
							<p class="text-sm text-default-600 mt-1 text-center">{ event.Description }</p>
						}
					</div>
					<div class="timeline-middle">
						<div class="timeline-circle"></div>
					</div>
					<div class="timeline-end timeline-date text-center">{ event.Date }</div>
				}
				if i < len(events)-1 {
					<hr class="timeline-hr-end"/>
				} else {
					<hr class="invisible timeline-hr-end"/>
				}
			</li>
		}
	</ul>
}

// TimelineEvent represents a single event in a timeline.
type TimelineEvent struct {
	Date        string
	Title       string
	Description string
}

// ParseTimelineEvents parses events from shortcode content.
// Format: date|title|description (one per line)
func ParseTimelineEvents(content string) []TimelineEvent {
	var events []TimelineEvent
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		parts := strings.SplitN(line, "|", 3)
		if len(parts) < 2 {
			continue
		}
		event := TimelineEvent{
			Date:  strings.TrimSpace(parts[0]),
			Title: strings.TrimSpace(parts[1]),
		}
		if len(parts) == 3 {
			event.Description = strings.TrimSpace(parts[2])
		}
		events = append(events, event)
	}
	return events
}
